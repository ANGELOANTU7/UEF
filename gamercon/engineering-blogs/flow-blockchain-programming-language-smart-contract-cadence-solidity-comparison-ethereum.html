<!DOCTYPE html><!-- This site was created in Webflow. https://www.webflow.com --><!-- Last Published: Mon Jul 17 2023 22:17:53 GMT+0000 (Coordinated Universal Time) --><html data-wf-domain="flow-com.webflow.io" data-wf-page="637380c394c328ab5ad74bb3" data-wf-site="5f734f4dbd95382f4fdfa0ea" lang="en">
<!-- Mirrored from flow.com/engineering-blogs/flow-blockchain-programming-language-smart-contract-cadence-solidity-comparison-ethereum by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jul 2023 16:22:28 GMT -->
<head><meta charset="utf-8"/><title>Cadence or Solidity: On-Chain Token Transfer Deep Dive</title><meta content="Jan 24, 2023" name="description"/><meta content="Cadence or Solidity: On-Chain Token Transfer Deep Dive" property="og:title"/><meta content="Jan 24, 2023" property="og:description"/><meta content="https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d027908396030df5ed4e6b_Blog%20Image%20-%20Comparing%20Cadence%20vs%20Solidity.png" property="og:image"/><meta content="Cadence or Solidity: On-Chain Token Transfer Deep Dive" property="twitter:title"/><meta content="Jan 24, 2023" property="twitter:description"/><meta content="https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d027908396030df5ed4e6b_Blog%20Image%20-%20Comparing%20Cadence%20vs%20Solidity.png" property="twitter:image"/><meta property="og:type" content="website"/><meta content="summary_large_image" name="twitter:card"/><meta content="width=device-width, initial-scale=1" name="viewport"/><meta content="goOrjM0FiQtmK2lUJ9Y5NpPJA-fMUUc_6Q6Vmd7-XIY" name="google-site-verification"/><meta content="Webflow" name="generator"/><link href="../../assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/css/flow-com.webflow.9325b97a3.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/" rel="preconnect"/><link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin="anonymous"/><script src="../../ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script><script type="text/javascript">WebFont.load({  google: {    families: ["Epilogue:300,regular,500,600,700,800,900,italic"]  }});</script><script src="../../use.typekit.net/mgu2ukv.js" type="text/javascript"></script><script type="text/javascript">try{Typekit.load();}catch(e){}</script><script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script><link href="../../assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/616b1520779838b5f9174363_favicon.png" rel="shortcut icon" type="image/x-icon"/><link href="../../assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/616b1548fd01d005fc2bc2c7_logo256.png" rel="apple-touch-icon"/><link href="flow-blockchain-programming-language-smart-contract-cadence-solidity-comparison-ethereum.html" rel="canonical"/><style>
  .w-webflow-badge {
    display: none !important;
  }
</style>


<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'../../www.googletagmanager.com/gtm5445.html?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-PWSGFLB');</script>
<!-- End Google Tag Manager -->


<meta name="facebook-domain-verification" content="dhlb5fcuitl7owilmsg6xh307ohoyc" />

<!-- Hotjar Tracking Code for Flow.com -->
<script>
    (function(h,o,t,j,a,r){
        h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
        h._hjSettings={hjid:3329982,hjsv:6};
        a=o.getElementsByTagName('head')[0];
        r=o.createElement('script');r.async=1;
        r.src=t+h._hjSettings.hjid+j+h._hjSettings.hjsv;
        a.appendChild(r);
    })(window,document,'https://static.hotjar.com/c/hotjar-','.js?sv=');
</script>
<link rel="stylesheet" href="../../cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" /></head><body><div data-animation="default" data-collapse="medium" data-duration="400" data-easing="ease" data-easing2="ease" role="banner" class="navigation w-nav"><div class="nav-container w-container"><a href="../index.html" class="nav-logo-div w-nav-brand"><img src="https://assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/63ce603ae36f46f6bb67e51e_flow-logo.svg" loading="lazy" alt="flow logo" class="hide"/><div aria-label="Flow logo" class="nav-logo__embed w-embed"><svg width="100" height="42" viewBox="0 0 100 42" fill="none" xmlns="http://www.w3.org/2000/svg">
<g clip-path="url(#clip0_106_24812)">
<path class="logotype" d="M57.3672 20.9501H54.6797V30.971H50.9297V20.9501H48.9922V17.7376H50.9297V16.4876C50.9297 13.2501 52.9505 11.5876 56.0214 11.5876C56.4968 11.5916 56.9705 11.6475 57.4339 11.7543V15.5043C57.0296 15.3422 56.5985 15.2574 56.163 15.2543C55.9663 15.2387 55.7684 15.2659 55.5832 15.334C55.3979 15.4021 55.2296 15.5096 55.0899 15.6489C54.9501 15.7883 54.8422 15.9563 54.7735 16.1414C54.7049 16.3264 54.6771 16.5242 54.6922 16.721V17.7168H57.3797L57.3672 20.9501ZM63.013 30.971H59.2214V11.871H63.013V30.971Z" fill="black"/>
<path class="logotype" d="M71.4292 16.9085C72.851 16.906 74.2415 17.3255 75.4247 18.1139C76.6079 18.9023 77.5306 20.024 78.0758 21.3371C78.6211 22.6502 78.7644 24.0956 78.4876 25.4902C78.2108 26.8848 77.5264 28.1658 76.5211 29.1712C75.5157 30.1766 74.2346 30.861 72.84 31.1377C71.4454 31.4145 70.0001 31.2712 68.687 30.726C67.3739 30.1807 66.2521 29.2581 65.4638 28.0749C64.6754 26.8917 64.2559 25.5011 64.2584 24.0793C64.2466 23.1344 64.4241 22.1967 64.7803 21.3213C65.1365 20.446 65.6642 19.6508 66.3325 18.9826C67.0007 18.3144 67.7959 17.7866 68.6712 17.4304C69.5465 17.0742 70.4842 16.8968 71.4292 16.9085V16.9085ZM71.4292 27.596C73.3667 27.596 74.7625 25.9877 74.7625 24.0793C74.7834 23.6288 74.7126 23.1787 74.5544 22.7563C74.3963 22.3339 74.1541 21.9481 73.8424 21.622C73.5308 21.296 73.1562 21.0366 72.7414 20.8595C72.3266 20.6824 71.8802 20.5914 71.4292 20.5918C70.5213 20.6232 69.661 21.0058 69.0298 21.6592C68.3986 22.3125 68.0458 23.1855 68.0458 24.0939C68.0458 25.0024 68.3986 25.8753 69.0298 26.5286C69.661 27.182 70.5213 27.5647 71.4292 27.596Z" fill="black"/>
<path class="logotype" d="M82.5576 17.1875L84.9951 26.3542L87.4326 19.0708L86.7659 17.1917H90.5159L93.7284 26.3583L96.1076 17.1917H99.9992L95.9034 30.975H91.9701L89.2284 23.4167L86.6659 30.9708H82.7076L78.6367 17.1875H82.5576Z" fill="black"/>
<path d="M20.8333 41.8334C32.3393 41.8334 41.6667 32.506 41.6667 21.0001C41.6667 9.49415 32.3393 0.166748 20.8333 0.166748C9.3274 0.166748 0 9.49415 0 21.0001C0 32.506 9.3274 41.8334 20.8333 41.8334Z" fill="#00EF8B"/>
<path d="M29.9732 17.7417H24.0898V23.625H29.9732V17.7417Z" fill="white"/>
<path d="M18.2138 25.8292C18.2138 26.266 18.0843 26.6929 17.8416 27.0561C17.599 27.4192 17.2541 27.7023 16.8506 27.8694C16.447 28.0366 16.003 28.0803 15.5746 27.9951C15.1463 27.9099 14.7528 27.6996 14.4439 27.3907C14.1351 27.0819 13.9248 26.6884 13.8396 26.26C13.7544 25.8316 13.7981 25.3876 13.9652 24.9841C14.1324 24.5806 14.4154 24.2357 14.7786 23.993C15.1417 23.7504 15.5687 23.6209 16.0055 23.6209H18.2138V17.7417H16.0055C14.4059 17.7417 12.8423 18.216 11.5123 19.1047C10.1823 19.9934 9.14572 21.2564 8.5336 22.7342C7.92147 24.212 7.76131 25.8382 8.07337 27.407C8.38543 28.9758 9.15569 30.4169 10.2867 31.5479C11.4178 32.679 12.8589 33.4492 14.4277 33.7613C15.9965 34.0733 17.6226 33.9132 19.1004 33.3011C20.5782 32.6889 21.8413 31.6523 22.73 30.3224C23.6186 28.9924 24.093 27.4287 24.093 25.8292V23.6209H18.2138V25.8292Z" fill="white"/>
<path d="M26.2984 14.8001H32.9151V8.91675H26.2984C24.1542 8.91895 22.0984 9.77174 20.5821 11.288C19.0659 12.8042 18.2131 14.86 18.2109 17.0042V17.7417H24.0901V17.0042C24.0912 16.4193 24.3244 15.8587 24.7384 15.4454C25.1524 15.0322 25.7135 14.8001 26.2984 14.8001V14.8001Z" fill="white"/>
<path d="M18.2109 23.6209H24.0901V17.7417H18.2109V23.6209Z" fill="#00EF8B"/>
</g>
<defs>
<clipPath id="clip0_106_24812">
<rect width="100" height="41.6666" fill="white" transform="translate(0 0.166748)"/>
</clipPath>
</defs>
</svg></div></a><nav role="navigation" class="new-navigation-menu w-nav-menu"><div data-hover="false" data-delay="0" class="w-dropdown"><div class="new-nav-link w-dropdown-toggle"><div class="nav-link-text">Solutions</div><div class="nav-link-dropdown-icon w-icon-dropdown-toggle"></div></div><nav class="navigation-dropdown-list w-dropdown-list"><a href="../hybrid-custody.html" class="navigation-dropdown-link w-dropdown-link">Walletless Onboarding +Hybrid Custody</a><a href="http://developers.flow.com/hybrid-custody/guides/account-abstraction" target="_blank" class="navigation-dropdown-link icon w-dropdown-link">Account Abstraction</a><a href="https://developers.flow.com/cadence" target="_blank" class="navigation-dropdown-link icon w-dropdown-link">Cadence</a></nav></div><div data-hover="false" data-delay="0" class="w-dropdown"><div class="new-nav-link w-dropdown-toggle"><div class="nav-link-text">Developers</div><div class="nav-link-dropdown-icon w-icon-dropdown-toggle"></div></div><nav class="navigation-dropdown-list w-dropdown-list"><a href="https://developers.flow.com/" target="_blank" class="navigation-dropdown-link icon w-dropdown-link">Developer portal</a><a href="https://github.com/onflow" class="navigation-dropdown-link w-dropdown-link">GitHub</a></nav></div><div data-hover="false" data-delay="0" class="w-dropdown"><div class="new-nav-link w-dropdown-toggle"><div class="nav-link-text">Ecosystem</div><div class="nav-link-dropdown-icon w-icon-dropdown-toggle"></div></div><nav class="navigation-dropdown-list ecosystem w-dropdown-list"><a href="https://www.flowverse.co/" target="_blank" class="navigation-dropdown-link icon w-dropdown-link">Flowverse</a></nav></div><div data-hover="false" data-delay="0" class="w-dropdown"><div class="new-nav-link w-dropdown-toggle"><div class="nav-link-text">Community</div><div class="nav-link-dropdown-icon w-icon-dropdown-toggle"></div></div><nav class="navigation-dropdown-list community w-dropdown-list"><a href="../flow-ambassador-program.html" class="navigation-dropdown-link w-dropdown-link">Ambassador program</a><a href="../blog.html" class="navigation-dropdown-link w-dropdown-link">Blog</a><a href="https://forum.onflow.org/" target="_blank" class="navigation-dropdown-link icon w-dropdown-link">Forum</a><a href="https://discord.com/invite/J6fFnh2xx6" target="_blank" class="navigation-dropdown-link discord w-dropdown-link">Discord</a><a href="https://twitter.com/flow_blockchain" class="navigation-dropdown-link twitter w-dropdown-link">Twitter</a></nav></div><div data-hover="false" data-delay="100" class="w-dropdown"><div class="new-nav-link w-dropdown-toggle"><div class="nav-link-text">About</div><div class="nav-link-dropdown-icon w-icon-dropdown-toggle"></div></div><nav class="navigation-dropdown-list ecosystem w-dropdown-list"><a href="../primer.html" class="navigation-dropdown-link w-dropdown-link">Primer</a><a href="../priorities.html" class="navigation-dropdown-link w-dropdown-link">Priorities</a><a href="../use-cases.html" class="navigation-dropdown-link w-dropdown-link">Use Cases</a><a href="../flow-token-economics.html" class="navigation-dropdown-link w-dropdown-link">Token economics</a><a href="../technical-paper.html" class="navigation-dropdown-link w-dropdown-link">Technical papers</a><a href="../sustainability.html" class="navigation-dropdown-link w-dropdown-link">Sustainability</a></nav></div></nav><div class="new-menu-button w-nav-button"><div class="w-icon-nav-menu"></div></div></div></div><div><div class="post-with-image-layout"><div class="blog-post-hero-2 wf-section"><div class="post-container w-container"><div><div class="blog-post-meta-data in-post"><div class="w-dyn-list"><div role="list" class="eng-blog-category-list w-dyn-items"><div role="listitem" class="w-dyn-item"><a href="../engineering-categories/blockchain.html" class="radius-text w-inline-block"><div class="eco-text-2">Blockchain</div></a></div><div role="listitem" class="w-dyn-item"><a href="../engineering-categories/cadence.html" class="radius-text w-inline-block"><div class="eco-text-2">Cadence</div></a></div><div role="listitem" class="w-dyn-item"><a href="../engineering-categories/smart-contracts.html" class="radius-text w-inline-block"><div class="eco-text-2">Smart Contracts</div></a></div></div></div><div class="small-dot-sep inpost left"></div><div class="blog-post-meta-text-data">January 24, 2023</div></div><div class="main-blog-post-title">Cadence or Solidity: On-Chain Token Transfer Deep Dive</div><div class="blog-post-meta-data post"><a href="../authors/jerome-pimmel.html" class="blog-post-meta-text-data dark">Jerome Pimmel</a><div class="small-dot-sep"></div><div class="blog-post-meta-text-data">Engineering @ Flow</div></div></div></div></div><div class="blog-post-section wf-section"><div class="container-25 _1280 w-container"><div class="post-info-parent"><div class="post-share-sidebar"><div class="social-share-btn-2 tw"></div><div class="social-share-btn-2 email"></div><div class="share-text">Share</div></div><div class="post-main-info-div eng"><img loading="lazy" src="../../assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d027908396030df5ed4e6b_Blog%20Image%20-%20Comparing%20Cadence%20vs%20Solidity.png" alt="Cadence or Solidity: On-Chain Token Transfer Deep Dive" sizes="(max-width: 479px) 83vw, (max-width: 767px) 92vw, (max-width: 991px) 81vw, 750px" srcset="https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d027908396030df5ed4e6b_Blog%20Image%20-%20Comparing%20Cadence%20vs%20Solidity-p-500.png 500w, https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d027908396030df5ed4e6b_Blog%20Image%20-%20Comparing%20Cadence%20vs%20Solidity-p-800.png 800w, https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d027908396030df5ed4e6b_Blog%20Image%20-%20Comparing%20Cadence%20vs%20Solidity-p-1080.png 1080w, https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d027908396030df5ed4e6b_Blog%20Image%20-%20Comparing%20Cadence%20vs%20Solidity.png 1600w" class="blog-post-main-image"/><div class="blog-post-rich-text-block w-richtext"><p>ERC-20 &amp; ERC-721 may be the most successful and widely adopted smart contract standards to date and have played a key role in the success of Ethereum. Despite this, the Cadence smart contract language on Flow chose to do things quite differently.</p><p>In this first of two articles we compare ERC-20/ERC-721 to their equivalents on Flow to illustrate the fundamental differences between Solidity and Cadence’s approach to token transfer. We look at how each smart contract language effects token transfer, and how the design of Cadence provides new language and security features to benefit both builders and users. We assume readers have a basic understanding of decentralized application development using Solidity or another smart contract language.</p><h2>The reference contracts</h2><p>As a Solidity reference, we use the excellent and commonly-used implementations of <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol" target="_blank">ERC-20</a> and <a href="https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol" target="_blank">ERC-721</a> as provided by the OpenZeppelin project.</p><h3>High level comparison basis</h3><p>The design of Cadence, and the <a href="https://github.com/onflow/flow-ft/blob/master/contracts/FungibleToken.cdc" target="_blank">Fungible Token</a> (FT) and <a href="https://github.com/onflow/flow-nft/blob/master/contracts/NonFungibleToken.cdc" target="_blank">Non-Fungible Token</a> (NFT) standards were informed by real-world experience with ERC-20 and ERC-721. (Indeed, one of the primary designers of both the language and the standards was the original author of ERC-721.) The respective language standards compare logically in terms of core functionality, in that they facilitate the exchange of tokens between parties. However, beyond the shared goals, that comparison breaks down at the interface and code level. However, the detailed nature of the functional and design differences between the two languages has important implications for builders which affect application design, security and composability.</p><h3>Comparing token transfer mechanics</h3><p>A defining feature of Solidity contracts is that each token contract stores and manages owners and access for balances or NFTs. In addition, Solidity relies on an address-based access and authorization model, where access to privileged functionality is via public methods which verify who you are by checking your address before executing any important functionality. By contrast, in Cadence, all tokens using the FT/NFT standards are first-class language types called Resources which exist programatically, and for which uniqueness is managed inherently by the language. Access and security is managed through <a href="https://developers.flow.com/cadence/language/capability-based-access-control" target="_blank">Capability-based access control</a>, programmatic objects similar to encryption keys which, when possessed, grant the bearer some scoped right of access to another object. As we will explain, Resources and Capabilities together with the Flow account model provide new primitives and distinct functionalities that absorb complexity instead of passing it onto developers making development of decentralized apps easier than ever.</p><h3>ERC-20 delegated transferFrom()</h3><p>The delegated token transfer pattern has become ubiquitous in EVM-based dapps and is an ideal example to illustrate some of the challenges that the address-based access model creates. This figure shows the typical program flow for an example GIBBON token ERC-20 contract when someone performs a delegated token transferFrom() from a dapp/service contract.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="../../assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d0143261fa44051d7becef_Solidity%20comparison%20-%20Page%204.png" loading="lazy" alt=""/></div></figure><p>The approve() step, a familiar process for Metamask users is required by most dapps as a pre-requisite to pretty much all functionality on EVM-based chains. The user approves the dapp contract, for a set amount, on the GIBBON contract before the user’s following interaction with dapp contract. The dapp contract then calls transferFrom() referencing the sender, thereby completing the 10 GIB transfer from the sender to itself.</p><p>When complete, the _balances mapping held in the GIBBON token contract will have decreased the token balance for the user account by the given amount (although no more than the amount specified in approve), and will also have increased the owner _balances mapping for the dapp contract address by that same amount. Fundamentally this is because the contract serves as a centralized ledger, recording owners mapped to their balances similar to a bank account.</p><div class="w-embed"><pre><code class="language-markup"><!--
	mapping(address => unit256) private _balances;
--!></code></pre></div><h3>Why delegation?</h3><p>Taking a step back, the reason why the approve() step is required on the GIBBON contract is because the contract IS the token and also stores the owner-to-balances mapping data. The approval given to the dapp contract has similarities to someone being given a signed bankers draft that permits them to withdraw the sender’s value for themselves. Consequently, approvals have become a critical part of the security fabric for Solidity, and for good reason. However, taking one step further back, the reason <em>why</em> the approval pattern must exist comes down to the address-centric nature of Solidity. Interactions with any Solidity contract assumes that the account interacting with the contract is the one executing the function. The runtime context provides the invoking contract’s address via the msg.sender property and it’s that address only which is being authorized during the function call.</p><div class="w-embed"><pre><code class="language-markup"><!--
function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
    address spender = _msgSender();
    _spendAllowance(from, spender, amount);
    _transfer(from, to, amount);
    return true;
}
--!></code></pre></div><p>Therefore, because dapp contract’s interaction with the GIBBON contract will reflect its address in msg.sender, the <em>only</em> way to facilitate acting on the sender’s behalf is to have first been authorized. Knowing this, the transferFrom() method internally performs this check before any changes are applied, which in the case of the OpenZeppelin base contract is handled in spendAllowance() and allowance() functions.</p><div class="w-embed"><pre><code class="language-markup"><!--
function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
    uint256 currentAllowance = allowance(owner, spender);
    if (currentAllowance != type(uint256).max) {
        require(currentAllowance >= amount, "ERC20: insufficient allowance");
        unchecked {
            _approve(owner, spender, currentAllowance - amount);
        }
    }
}

function allowance(address owner, address spender) public view virtual override returns (uint256) {
    return _allowances[owner][spender];
}
--!></code></pre></div><h2>Cadence is different, but how?</h2><p>As was touched upon earlier, Cadence introduces new concepts into the picture which makes it possible to solve token transfer very differently. To understand the mechanics of token transfer in Cadence it’s essential to know the following:</p><h3>The account model</h3><p>The <a href="https://developers.flow.com/cadence/language/accounts" target="_blank">account model</a> in Cadence combines storage for the keys and code (”smart contracts”) associated with an account with storage for the assets owned by that account. That’s right: In Cadence, your tokens are stored in your account, and not in a smart contract. Of course, smart contracts still define these assets and how they behave, but those assets can be securely stored in a user’s account through the magic of Resources.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d025be1c21e00c2cbff56b_Solidity%20comparison%20-%20Page%206.png" loading="lazy" alt=""/></div></figure><h3>Resources</h3><p>Resources are unique, <a href="https://en.wikipedia.org/wiki/Substructural_type_system#Linear_type_systems" target="_blank">linear-types</a> which can never be copied or implicitly discarded, only moved between accounts. If, during development, a function fails to store a Resource obtained from an account in the function scope, semantic checks will flag an error. The run-time enforces the same strict rules in terms of allowed operations. Therefore contract functions which do not properly handle Resources in scope before exiting will abort, reverting them to the original storage. These features of Resources make them perfect for representing tokens, both fungible and non-fungible. Ownership is tracked by where they are stored, and the assets can’t be duplicated or accidentally lost since the language itself enforces correctness.</p><h3>Capabilities</h3><p>Remote access to stored objects can be delegated via <a href="https://developers.flow.com/cadence/language/capability-based-access-control" target="_blank">Capabilities</a>. This means that if an account wants to be able to access another account&#x27;s stored objects, it must have been provided with a valid Capability to that object. Capabilities can be either public or private. An account can share a public Capability if it wants to give all other accounts access. (For example, it’s common for an account to accept fungible token deposits from all sources via a public Capability.) Alternatively, an account can grant private Capabilities to specific accounts in order to provide access to restricted functionality. For example, an NFT project often controls minting through an “administrator Capability” that grants specific accounts with the power to mint new tokens.</p><h3>Contract standards</h3><p>The Cadence FT contract standard defines a contract interface to be implemented similarly to ERC-20. However, the standard also extends into sub-types such as Resources, Resource interfaces, or other types. The standard is thus able to define and limit behaviour and/or set conditions which FT implementations cannot violate. Specifically, the FT standard defines a <a href="https://github.com/onflow/flow-ft/blob/master/contracts/FungibleToken.cdc#L156" target="_blank">Vault</a> Resource subtype meaning that all implementations of the standard must implement the same Vault Resource type, with the same interfaces and functions., with the same interfaces and functions. Provider, Receiver, and Balance Resource interfaces separate vault interactions and are used for fine grained security control as we’ll expand on later. Function pre and post conditions specified in FT standard vault functions are enforced at runtime for FT implementations. The standard leaves out minting, creation and other concerns as these may vary depending on the project. The class diagram below shows the FT contract standard and how the FLOW token has implemented it.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d025cce33435e57f02d934_Solidity%20comparison%20-%20Page%205%20(2).png" loading="lazy" alt=""/></div></figure><h2>Freedom from msg.sender!</h2><p>To understand why these new concepts matter we’ll quickly dip into some history. The development of Cadence as a language started in 2018 by the Dapper Labs team who had long struggled with Solidity’s limitations. The most frustrating aspects of engineering decentralized applications trace back to address-based access which makes contracts very difficult to compose. Composability in Web3 is the idea that a contract serves as a lego-block around which other contracts can be built, combining their functionalities additively. For example, if a game contract stores win/loss results on-chain for games played, another contract can be created that uses the win/loss data to surface top players in a leaderboard. Another contract might go even further, using the win/loss history to calculate odds for betting on players’ future games. However, due to address-based access, contract calls are firmly gated on who someone is. This makes it impossible for two contracts to interact if the first contract doesn’t have access to the second contract, even if the user has access to both.</p><p>The directionality of access controls in Solidity is from the protected function to the subjects that are authorized. Consequently contracts internalize authorizations and inspect all addresses who access the protected function.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d025e0df1e61e348f47372_Solidity%20comparison%20-%20Page%209.png" loading="lazy" alt=""/></div></figure><p>Cadence reverses the access-based paradigm with Capabilities. Once obtained, Capabilities grant access from the subject to the protected function (or Resource) so the contract no longer needs to authorize addresses. This is because access to a protected object is <em>only possible</em> through the Capability using borrow(). Goodbye msg.sender!</p><figure class="w-richtext-figure-type-image w-richtext-align-center" class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d025f4a793922e2cd6dc1f_Solidity%20comparison%20-%20Page%208%20(1).png" loading="lazy" alt=""/></div></figure><p>The implications for composability are significant. If contracts aren’t required to know upfront for whom interactions are on behalf of, it’s possible for users to interact with any arbitrary number of contracts and their functions during a transaction providing they have the Capabilities. It also means that contracts <em>can interact directly with one another</em> with no approvals or other setup, the only requirement is that the calling contract possesses the needed Capabilities. For a more detailed, deep dive into the expansive and exciting possibilities for composability on Flow stay tuned for a future article currently in the works!</p><h2>From the authority delegation mindset to domain-driven coding</h2><p>Rather than code directly interacting with a FT token contract, the first step is to interact with an account to obtain a Capability for the specific FT token type. In the figure we see the Capability is for the FLOW vault, as identified by its public path argument (and yes, you can list public capabilities that accounts have). The Capability instance returned enables the bearer to borrow() the referenced vault Resource, in this case the FLOW vault object. In our example the return type is restricted to the FT receiver Resource interface. This strictly limits what can be called on the vault reference to only the deposit() function.</p><p>As we’ll explore below, the code for this is intuitive, object-oriented and types clearly pertain to the token transfer domain in question.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d02603d97db5bd99963042_Solidity%20comparison%20-%20Page%2010%20(1).png" loading="lazy" alt=""/></div></figure><h2>Essential transaction elements</h2><p>Let’s use your new-found understanding of Capability-based access and the FT standard to walk through the basic elements needed for the transfer transaction.</p><h3>1. Obtain the provider vault to withdraw from</h3><p>As the previous section outlined, obtaining access to the user’s vault containing the funds is a required first step. In this step the user is the party whose funds are being sent and for whom the transaction is being executed, so they can directly access their own provider vault using borrow() without first obtaining a Capability.</p><div class="w-embed"><pre><code class="language-markup"><!--
// The Vault Resource that holds the tokens that are being transferred
let interimVault: @FungibleToken.Vault

prepare(provider: AuthAccount) {

	// Get a reference to the provider's FLOW vault
	let vaultRef = provider.borrow<&FlowToken.Vault>(from: FlowToken.VaultStoragePath)
		?? panic("Could not borrow reference to the provider's Vault!")

	// Withdraw tokens from the provider's vault
	self.interimVault <- vaultRef.withdraw(amount: amount)
}
--!></code></pre></div><p>The interimVault constant is defined at the top of the transaction code to temporarily hold tokens withdrawn from the provider before depositing to the recipient. Perhaps subtly, the movement of provider vault tokens to interimVault using the move &lt;- operator validates the amount to be withdrawn is available. These steps both occur in the prepare block of the transaction which is for loading objects from providers’ storage. If the provider has insufficient tokens, or if a vault is somehow not available, the transaction will abort.</p><h3>2. Obtain a receiver vault reference to deposit to</h3><p>Cadence transactions occur in two phases, the execute phase of which is for working with previously obtained provider Resources and interacting with other accounts. When prepare has completed successfully the execute phase will run. Note that in this phase the receiver vault Resource reference must be obtained via the receiver account’s public Capability, since otherwise there would be no access.</p><div class="w-embed"><pre><code class="language-markup"><!--
execute {

	// Get the recipient's public account object
	let recipient = getAccount(to)

  // Get a reference to the recipient's FLOW vault receiver
  let receiverRef = recipient.getCapability(FlowToken.ReceiverPublicPath)
	  .borrow<&{FungibleToken.Receiver}>()
		?? panic("Could not borrow receiver reference to the recipient's Vault")

    // Deposit the withdrawn tokens in the recipient's receiver
    receiverRef.deposit(from: <-self.interimVault)
}
--!></code></pre></div><p>From the account we obtain the public Capability matching FlowToken.ReceiverPublicPath then borrow the FLOW vault receiver reference via that Capability. We conclude the transaction by depositing the amount held in interimVault into the recipients token vault using the move &lt;- operator. On completion, the transaction is committed. If at any time a panic occurs in either phase, the entire transaction is aborted.</p><h2>Putting it all together</h2><p>As the above code snippets may have hinted, transactions in Cadence differ from Solidity in that they can contain any arbitrary amount of code rather than just a single function call. In the complete example below, contract imports for the FT standard and FLOW token establish the needed types resolve into the transaction scope, after which interacting with those types follows standard object-oriented programming conventions.</p><div class="w-embed"><pre><code class="language-markup"><!--
import FungibleToken from 0xFUNGIBLETOKENADDRESS
import FlowToken from 0xTOKENADDRESS

transaction(amount: UFix64, to: Address) {

    // The Vault Resource that holds the tokens that are being transferred
    let interimVault: @FungibleToken.Vault

    prepare(provider: AuthAccount) {

        // Get a reference to the provider's FLOW vault
        let vaultRef = provider.borrow<&FlowToken.Vault>(from: FlowToken.VaultStoragePath)
			?? panic("Could not borrow reference to the provider's Vault!")

        // Withdraw tokens from the provider's vault
        self.interimVault <- vaultRef.withdraw(amount: amount)
    }

    execute {

        // Get the recipient's public account object
        let recipient = getAccount(to)

        // Get a reference to the recipient's FLOW vault receiver
        let receiverRef = recipient.getCapability(FlowToken.ReceiverPublicPath)
            .borrow<&{FungibleToken.Receiver}>()
			?? panic("Could not borrow receiver reference to the recipient's Vault")

        // Deposit the withdrawn tokens in the recipient's receiver
        receiverRef.deposit(from: <-self.interimVault)
    }
}
--!></code></pre></div><h3>How is this secure, can’t anyone access the full funds from the vaults in scope?</h3><p>At first glance it may seem worryingly insecure to grant access to account vaults. However, initial <a href="https://github.com/onflow/flow-core-contracts/blob/master/transactions/flowToken/setup_account.cdc" target="_blank">account setup</a> ensures that publicly accessible Capabilities also scope down access privileges to prevent clients from accessing the full vault interface. This example shows how the FLOW token contract scopes down access when linking the Capability for the token vault into the account during initial setup:</p><div class="w-embed"><pre><code class="language-markup"><!--
// Create a public capability to the Vault that only exposes
// the deposit function through the Receiver interface
signer.link<&FlowToken.Vault{FungibleToken.Receiver}>(
    /public/flowTokenReceiver,
    target: /storage/flowTokenVault
)
--!></code></pre></div><p>The linked Capability returns an <em>attenuated</em> reference to the account vault, only exposing the FlowToken.Vault{FungibleToken.Receiver} interface. This enforces that no other functions can be called on the vault despite the source object having a broader API surface area. The use of attenuation to scope down access via the exposed Capability is one of Cadence’s unique and commonly observed security control mechanisms.</p><h2>The truth about delegation in Cadence</h2><p>The keen eyed among you may have observed the transfer example above isn’t delegating control. The fact is, an apples-to-apples comparison of delegated transfer isn’t possible between Solidity &amp; Cadence due to the differences in address-vs-Capability-based security models. That being said, delegation is possible - just not in the way that Solidity does it.</p><h3>Delegation via Capability</h3><p>The simplest way of delegating access or control is via Capabilities. If Alice decides to delegate a token transfer to Bob, allowing him to spend some of her funds on something, she would issue a private Capability to Bob specifically granting access to the provider resource interface on her token vault. Access to withdraw unlimited funds from Alice’s main FLOW vault is obviously not desirable. With Capabilities it’s possible to design expressive and creative solutions best suited to ones use cases, and the examples here are just some of the ways one might use to implement delegation.</p><ol role="list"><li>Create a new, temporary Flow vault in Alice’s account funded with the limited funds that Alice will allow Bob to withdraw. Then link a private Capability to that vault and provide it to Bob</li><li>Create a new Resource - ScopedProvider in our example (<a href="https://gist.github.com/sisyphusSmiling/418ca0bd9a734eb6750f40449c849140" target="_blank">full example Gist</a>) - implementing the Provider interface. In that resource, we save a provider Capability on Alice’s Vault and enforce a withdrawal limit with the wrapping Resource’s withdraw() method. The ScopedProvider can then be saved in Alice&#x27;s account, its provider Capability linked and given to Bob</li></ol><div class="w-embed"><pre><code class="language-markup"><!--
/// Resource wrapping a Provider Capability to enforce a withdrawal limit
pub resource ScopedProvider : FungibleToken.Provider {
  /// Track how much has been withdrawn
  pub var withdrawn: UFix64
  /// Set a limit on withdrawal
  pub let withdrawalLimit: UFix64
  /// Maintain a Capability to the source Provider
  pub let sourceProvider: Capability<&{FungibleToken.Provider}>

  init(
    _ withdrawalLimit: UFix64,
    _ sourceProvider: Capability<&{FungibleToken.Provider}>
  ) {
    pre {
      sourceProvider.check(): "Problem with given Provider Capability!"
    }
    /* Assign resource variables on init */
    self.withdrawn = 0.0
    self.withdrawalLimit = withdrawalLimit
    self.sourceProvider = sourceProvider
  }
  
  /// Provider.withdraw method implementation that enforces withdrawal limit
  pub fun withdraw(amount: UFix64): @FungibleToken.Vault {
    pre {
      self.withdrawn + amount <= self.withdrawalLimit: "Amount exceeds remaining withdrawal limit!"
    }
    // Increment withdrawn amount before withdrawing
    self.withdrawn = self.withdrawn + amount
    // Get a reference to the Provider given on init
    let sourceProviderRef = self.sourceProvider.borrow()!
    // Return a Vault withdrawn from the source provider
    return <-sourceProviderRef.withdraw(amount: amount)
  }
}
--!></code></pre></div><p>       3. <a href="https://forum.onflow.org/t/hybrid-custody/4016" target="_blank">Hybrid custody!</a> A ground breaking feature, unique to Flow, that is soon to be released. Stay tuned, <em>it might just blow your mind!</em></p><h2>What’s the story with Cadence transactions?</h2><p>Another major difference between Cadence and Solidity is that deployed contracts are not the only code being executed in the VM. Cadence offers scripts, of which a subset are transactions, and both permit arbitrary code. Scripts or transactions are not deployed on-chain and always exist off-chain, however, they are the top-level code payload being executed by the execution runtime. Clients send scripts and transactions through the Flow Access API gRPC or REST endpoints, returning results to clients when applicable. Scripts and transactions enable more efficient and powerful ways to integrate dapps with the underlying blockchain, where contracts can more purely be thought of as services or components, with scripts or transactions becoming the dapp-specific API interface for chain interactions.</p><p>Scripts are read-only in nature, requiring only a main function declaration and which perform <a href="https://github.com/onflow/flow-ft/blob/master/transactions/scripts/get_balance.cdc" target="_blank">queries</a> against chain state, eg:</p><div class="w-embed"><pre><code class="language-markup"><!--
// This script reads the balance field of an account's ExampleToken Balance
import FungibleToken from "../../contracts/FungibleToken.cdc"
import ExampleToken from "../../contracts/ExampleToken.cdc"

pub fun main(account: Address): UFix64 {
    let acct = getAccount(account)
    let vaultRef = acct.getCapability(ExampleToken.VaultPublicPath)
        .borrow<&ExampleToken.Vault{FungibleToken.Balance}>()
        ?? panic("Could not borrow Balance reference to the Vault")

    return vaultRef.balance
}
--!></code></pre></div><p><a href="https://github.com/onflow/flow-ft/tree/master/transactions" target="_blank">Transactions</a> are an ACID (Atomic, Consistent, Isolated and Durable) version of scripts having only prepare and execute functions that either succeed in full and mutate chain state as described, or otherwise fail and mutate nothing. They also support setting of pre and post conditions. In the example transaction below ExampleTokens are deposited into multiple receiver vaults for each address in the input map.</p><div class="w-embed"><pre><code class="language-markup"><!--
import FungibleToken from "../contracts/FungibleToken.cdc"
import ExampleToken from "../contracts/ExampleToken.cdc"

/// Transfers tokens to a list of addresses specified in the `addressAmountMap` parameter
transaction(addressAmountMap: {Address: UFix64}) {

    // The Vault resource that holds the tokens that are being transferred
    let vaultRef: &ExampleToken.Vault

    prepare(signer: AuthAccount) {

        // Get a reference to the signer's stored vault
        self.vaultRef = signer.borrow<&ExampleToken.Vault>(from: ExampleToken.VaultStoragePath)
			?? panic("Could not borrow reference to the owner's Vault!")
    }

    execute {

        for address in addressAmountMap.keys {

            // Withdraw tokens from the signer's stored vault
            let sentVault <- self.vaultRef.withdraw(amount: addressAmountMap[address]!)

            // Get the recipient's public account object
            let recipient = getAccount(address)

            // Get a reference to the recipient's Receiver
            let receiverRef = recipient.getCapability(ExampleToken.ReceiverPublicPath)
                .borrow<&{FungibleToken.Receiver}>()
                ?? panic("Could not borrow receiver reference to the recipient's Vault")

            // Deposit the withdrawn tokens in the recipient's receiver
            receiverRef.deposit(from: <-sentVault)

        }
    }
}
--!></code></pre></div><p>Transactions can encompass an arbitrary number withdrawals/deposits, across multiple FTs, sending to multiple addresses, or other more complex variations, all of which will succeed or fail in their entirety given their ACID properties.</p><h3>Post transaction state</h3><p>We’ve covered the runtime mechanics of token transfer for Solidity and Cadence’s respective token standards and you should have a clear understanding of implementation and design differences that set them apart. However, the story is not complete until we unpack what we’re left with on-chain after these transactions complete.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d026b2e11084a613b0ebb7_Solidity%20comparison%20-%20Page%202%20(2).png" loading="lazy" alt=""/></div></figure><p>As mentioned _balances is where Solidity contracts maintain ledger mapping entries. Wallets bring these balances together into a coherent singular view for the user. Assuming that I just completed a transferFrom() using my GIBBON token, my wallet would update the balance for GIBBON token by calling its balanceOf() method.</p><p>Since account 0x001 possesses multiple tokens, the wallet queries balanceOf() against each respective ERC-20 compliant token contract.</p><p>Unsurprisingly, Cadence leverages the account model, holding a vault for each different token type as needed. Because of this there’s no need for a wallet to create a unified view - it’s equally possible to see an account’s balances across all tokens possessed by inspecting the account using the <a href="https://developers.flow.com/tools/flow-cli" target="_blank">flow-cli</a> or other online tools.</p><figure class="w-richtext-figure-type-image w-richtext-align-center" class="w-richtext-align-center w-richtext-figure-type-image"><div><img src="https://assets-global.website-files.com/618c953e65cc2ba3f44d1a02/63d026bbb897f3170ffdd723_Solidity%20comparison%20-%20Page%207%20(2).png" loading="lazy" alt=""/></div></figure><h2>Framing ownership</h2><p>The distinction in how ownership of tokens is framed between Solidity and Cadence is perhaps the most significant contrasting aspect of their philosophies. Resources, the account model and Capability-based access are potently combined through the FT standard to realize token ownership as domain centric primitives that are easy to reason about and expand the solution-space for builders. Whereas Solidity maintains owner balance records - similar to a bank account - vaults in Cadence ensure tokens are owned in your account like having cash in your wallet. Access to contract interfaces and functions is managed by Capabilities owned by those interacting with a contract. Indeed, the philosophy to which builders need to adjust to is perhaps best summed up as “<em>it’s not who you are, but what you have”</em> that defines how contract interactions happen in Cadence. As we’ll explore in the next article, ownership of NFTs also follows the same principles, additionally providing rich semantics for managing NFT collections, network-wide discoverability and reach for listings and offers, and beneath it all how wonderful it is that all metadata lives on-chain with your NFT.</p><h3>Coming soon.. NFT transfers and composability</h3><p>In this article we explored how fungible token transfers work each language and how the contrasts run through design and mindset all the way to how data and compute are handled on-chain. We highlighted how limitations arising from Solidity’s simple, access-based model can prove problematic, how that affects composability, and how Cadence offers a powerful and compelling alternative. With the industry at a critical inflection point, where real-life utility and composability use-cases still demonstrably fall short of the promised future, Cadence empowers builders with a realistic and practical way to push the frontiers of decentralized application engineering. The global, <a href="https://github.com/onflow/cadence">open source</a> engineering community now evolving Cadence remain super focused on creating the most fit-for-purpose, effective and secure smart contract language for current and future generations of Web3 builders. Many of the novel language features shared above, and all of the ground-breaking new features coming soon include numerous critical contributions from the community.</p><p>If you want to learn more about <a href="https://developers.flow.com/cadence/" target="_blank">Cadence</a>, or to participate in the community, we invite you to join our <a href="https://discord.gg/flow" target="_blank">discord</a>! Check out our <a href="https://developers.flow.com/cadence/solidity-to-cadence" target="_blank">detailed guide for Solidity developers</a> and the many <a href="https://developers.flow.com/" target="_blank">other resources</a> for developers. We look forward to seeing what exciting solutions you end up building in the coming years and would love for you to tag us on <a href="https://twitter.com/flow_blockchain" target="_blank">Twitter</a>, hashtag #onFlow!</p><p>Stay tuned for Part 2 where we’ll deep dive into the comparison between ERC-721 and the corresponding Cadence standard for NFT transfers!</p><p>‍</p></div><div class="tags-post-div"><div class="tags-title-14">Tags:</div><div class="w-dyn-list"><div role="list" class="tag-cloud w-dyn-items"><div role="listitem" class="w-dyn-item"><div class="tags-title">Blockchain</div></div><div role="listitem" class="w-dyn-item"><div class="tags-title">Cadence</div></div><div role="listitem" class="w-dyn-item"><div class="tags-title">Coding</div></div><div role="listitem" class="w-dyn-item"><div class="tags-title">Crypto</div></div><div role="listitem" class="w-dyn-item"><div class="tags-title">Smart Contracts</div></div><div role="listitem" class="w-dyn-item"><div class="tags-title">Programming</div></div><div role="listitem" class="w-dyn-item"><div class="tags-title">Web 3</div></div></div></div></div></div></div></div></div></div><div class="post-with-text-layout hide"><div class="blog-post-hero-2 no-image wf-section"><div class="post-container w-container"><div><div class="blog-post-meta-data in-post"><div class="blog-post-category">Studio</div><div class="small-dot-sep"></div><div class="blog-post-meta-text-data">03/30/2021</div></div><div class="main-blog-post-title">Welcoming Animoca, MotoGP, and StarGirl to Flow</div><div class="blog-post-meta-data post"><div class="blog-post-meta-text-data dark">Mik Naayem</div><div class="small-dot-sep"></div><div class="blog-post-meta-text-data">CBO and Cofounder at Dapper Labs</div></div></div></div></div><div class="blog-post-section wf-section"><div class="container-25 _1280 w-container"><div class="post-info-parent no-img"><div class="post-share-sidebar"><div class="social-share-btn-2 tw"></div><div class="social-share-btn-2 email"></div><div class="share-text">Share</div></div><div class="post-main-info-div"><div class="blog-post-rich-text w-richtext"><p>The rich text element allows you to create and format headings, paragraphs, blockquotes, images, and video all in one place instead of having to add and format them individually. Just double-click and easily create content.</p><ul role="list"><li>Decentralized because you can set up a blockchain system so that every entity can only make changes within its predefined purview. Companies can also use permissionless, permissioned, or hybrid-approach blockchains, allowing for useful trade-offs between network security and system privacy.</li><li>Decentralized because you can set up a blockchain system so that every entity can only make changes within its predefined purview. Companies can also use permissionless, permissioned, or hybrid-approach blockchains, allowing for useful trade-offs between network security and system privacy.</li><li>scscsssc</li></ul><h4>Static and dynamic content editing</h4><blockquote>A rich text element can be used with static or dynamic content. For static content, just drop it into any page and begin editing. For dynamic content, add a<a href="http://www.google.com"> rich text field to any collection</a> and then connect a rich text element to that field in the settings panel. Voila!</blockquote><h4>How to customize formatting for each rich text</h4><p>Headings, paragraphs, blockquotes, figures, images, and figure captions can all be styled after a class is added to the rich text element using the &quot;When inside of&quot; nested selector system.</p></div></div></div></div></div></div><div class="section-32 wf-section"><div class="container-25 _1280 w-container"><div class="title-div-3"><div>Related Content</div></div><div class="w-dyn-list"><div role="list" class="w-dyn-items"><div role="listitem" class="w-dyn-item"><div class="blog-post-parant-div first"><div class="blog-post-info-div"><a href="/engineering-blogs/upgrading-flows-consensus-follower-to-boost-attack-resilience-and-processing-speed" class="blog-post-title">Upgrading Flow&#x27;s Consensus Follower to boost attack resilience and processing speed</a><div class="blog-post-meta-data"><div class="blog-post-meta-text-data">May 30, 2023</div><div class="small-dot-sep"></div><div class="blog-post-meta-text-data">Jordan Schalm</div></div></div></div></div><div role="listitem" class="w-dyn-item"><div class="blog-post-parant-div first"><div class="blog-post-info-div"><a href="/engineering-blogs/jolteon-advancing-flows-consensus-algorithm" class="blog-post-title">Jolteon: Advancing Flow’s consensus algorithm</a><div class="blog-post-meta-data"><div class="blog-post-meta-text-data">Apr 14, 2023</div><div class="small-dot-sep"></div><div class="blog-post-meta-text-data">Jordan Schalm</div></div></div></div></div><div role="listitem" class="w-dyn-item"><div class="blog-post-parant-div first"><div class="blog-post-info-div"><a href="/engineering-blogs/golang-services-improving-observability" class="blog-post-title">Improving Observability of GoLang Services</a><div class="blog-post-meta-data"><div class="blog-post-meta-text-data">Jan 31, 2023</div><div class="small-dot-sep"></div><div class="blog-post-meta-text-data">Alexey Ivanov</div></div></div></div></div></div></div></div></div></div><div class="section footer wf-section"><div class="footer-div"><div class="join-text-2 no-hover">Join Flow on</div><a href="https://twitter.com/flow_blockchain" target="_blank" class="join-text-2">Twitter</a><a href="https://discord.com/invite/J6fFnh2xx6" target="_blank" class="join-text-2">Discord</a><a href="https://flow.com/" target="_blank" class="join-text-2">flow.com</a></div></div><div class="new-footer wf-section"><div class="container w-container"><div class="w-layout-grid _3-footer-grid"><div><a id="w-node-ec243fb8-8059-5bdb-528d-ce0b082ca18b-082ca187" href="/" class="footer-logo-link w-inline-block"><img src="https://assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/63ce603ae36f46f6bb67e51e_flow-logo.svg" loading="lazy" alt="flow logo" class="footer-logo-img"/></a><div class="footer-social-icons"><a href="https://twitter.com/flow_blockchain" target="_blank" class="footer-social-icon w-inline-block"><img src="https://assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/63cec770abbeba426e358f76_Twitter%20-%20Negative.svg" loading="lazy" alt="social icon"/></a><a href="https://www.instagram.com/flowblockchain" target="_blank" class="footer-social-icon w-inline-block"><img src="https://assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/63cec770799e2958d15306a0_Instagram%20-%20Negative.svg" loading="lazy" alt="social icon"/></a><a href="https://www.youtube.com/@FlowBlockchain" target="_blank" class="footer-social-icon w-inline-block"><img src="https://assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/63cec77005a49eaba248e147_YouTube%20-%20Negative.svg" loading="lazy" alt="social icon"/></a><a href="https://t.me/flow_blockchain" target="_blank" class="footer-social-icon w-inline-block"><img src="https://assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/63cec770b75d5482a08014db_Telegram%20-%20Negative.svg" loading="lazy" alt="social icon"/></a><a href="https://discord.com/invite/J6fFnh2xx6" target="_blank" class="footer-social-icon last w-inline-block"><img src="https://assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/63d0398494fe5d96e72f4cc0_Social%20Icon.svg" loading="lazy" alt="social icon"/></a></div></div><div id="w-node-_843ebe60-d3a2-032c-780e-737a5989cba0-082ca187"><div class="footer-column-header">Start Building</div><a href="https://developers.flow.com/" target="_blank" class="new-footer-link">Developer portal</a><a href="https://github.com/onflow" target="_blank" class="new-footer-link">GitHub</a></div><div id="w-node-ec243fb8-8059-5bdb-528d-ce0b082ca19f-082ca187"><div class="footer-column-header">Flow</div><a href="https://docs.google.com/forms/d/e/1FAIpQLSer5ZX0pRWsXF0U0bsgW4Zo8Pmlw0V927ZydDq_ej-qyIJ9_A/viewform" target="_blank" class="new-footer-link">Business Development</a><a href="https://flow.com/node-operation" target="_blank" class="new-footer-link">Node Operation</a><a href="/token-distribution" class="new-footer-link">Token Distribution</a><a href="/mediakit" class="new-footer-link">Media Kit</a><a href="/careers" class="new-footer-link">Careers</a><a href="/faq" class="new-footer-link">FAQ</a></div><div id="w-node-ec243fb8-8059-5bdb-528d-ce0b082ca198-082ca187"><div class="footer-column-header">Get Connected</div><a href="https://port.onflow.org/" target="_blank" class="new-footer-link">Flow Port</a><a href="https://www.flowverse.co/" target="_blank" class="new-footer-link">Flowverse</a></div></div><div class="div-block-129"><div class="footer-copyright">© 2023 All Rights Reserved</div></div></div></div><script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=5f734f4dbd95382f4fdfa0ea" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script><script src="https://assets-global.website-files.com/5f734f4dbd95382f4fdfa0ea/js/webflow.2724f1538.js" type="text/javascript"></script><!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-NHJB3BPPXG"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-NHJB3BPPXG');
</script>

<!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PWSGFLB"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) --><script src="../../cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="../../cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/unescaped-markup/prism-unescaped-markup.min.js"></script></body>
<!-- Mirrored from flow.com/engineering-blogs/flow-blockchain-programming-language-smart-contract-cadence-solidity-comparison-ethereum by HTTrack Website Copier/3.x [XR&CO'2014], Sat, 22 Jul 2023 16:22:37 GMT -->
</html>